const { 
  USER_ROLES, 
  PERMISSIONS, 
  FINANCIAL_FIELDS, 
  VALIDATION_RULES, 
  ERROR_MESSAGES,
  AUDIT_LEVELS 
} = require('../utils/constants');

class ValidationMiddleware {
  constructor() {
    this.rateLimits = new Map();
  }

  sanitize(input) {
    if (typeof input !== 'string') return input;
    return input.replace(/[<>\"'&]/g, (match) => {
      const chars = { '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '&': '&amp;' };
      return chars[match];
    });
  }

  checkRateLimit(identifier, maxAttempts = 10, windowMs = 15 * 60 * 1000) {
    const now = Date.now();
    const key = `${identifier}_${Math.floor(now / windowMs)}`;
    const attempts = this.rateLimits.get(key) || 0;
    
    if (attempts >= maxAttempts) {
      throw new Error('Rate limit exceeded. Please try again later.');
    }
    
    this.rateLimits.set(key, attempts + 1);
  }

  validateLogin(data) {
    this.checkRateLimit(data.email || 'unknown', 5, 15 * 60 * 1000);
    
    if (!data.email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
      throw new Error('Valid email is required');
    }
    if (!data.password || data.password.length < 8) {
      throw new Error('Password must be at least 8 characters');
    }
    
    return {
      email: this.sanitize(data.email.toLowerCase().trim()),
      password: data.password
    };
  }

  validateUserRegistration(data, currentUserRole) {
    // Only admins can create users
    if (currentUserRole !== USER_ROLES.ADMIN) {
      throw new Error(ERROR_MESSAGES.ADMIN_ONLY_OPERATION);
    }
    
    this.checkRateLimit(`registration_${data.email}`, 3, 10 * 60 * 1000);
    
    if (!data.email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
      throw new Error('Valid email is required');
    }
    
    // Enhanced password validation
    if (!data.password || data.password.length < 8 || !/^(?=.*[a-zA-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/.test(data.password)) {
      throw new Error('Password must contain letters, numbers, and special characters');
    }
    
    if (!data.firstName || !data.lastName || data.firstName.length < 2 || data.lastName.length < 2) {
      throw new Error('First and last names are required (2+ characters)');
    }
    
    if (!/^[a-zA-Z\s]+$/.test(data.firstName) || !/^[a-zA-Z\s]+$/.test(data.lastName)) {
      throw new Error('Names can only contain letters and spaces');
    }
    
   const validated = {
  email: this.sanitize(data.email.toLowerCase().trim()),
  firstName: this.sanitize(data.firstName.trim()),
  lastName: this.sanitize(data.lastName.trim()),
  role: USER_ROLES.ASSISTANT
};

// Include password if provided, otherwise backend will generate one
if (data.password && data.password.trim()) {
  validated.password = data.password.trim();
}

return validated;
  }

  validateAssistant(data, currentUserRole) {
    // Only admins can create assistants
    if (currentUserRole !== USER_ROLES.ADMIN) {
      throw new Error(ERROR_MESSAGES.ADMIN_ONLY_OPERATION);
    }
    
    this.checkRateLimit(`assistant_creation_${data.email}`, 3, 10 * 60 * 1000);
    
    if (!data.email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
      throw new Error('Valid email is required');
    }
    
    if (!data.firstName || !data.lastName || data.firstName.length < 2 || data.lastName.length < 2) {
      throw new Error('First and last names are required (2+ characters)');
    }
    
    if (!/^[a-zA-Z\s]+$/.test(data.firstName) || !/^[a-zA-Z\s]+$/.test(data.lastName)) {
      throw new Error('Names can only contain letters and spaces');
    }
    
    // Password is NOT required - it will be generated by the controller
    return {
      email: this.sanitize(data.email.toLowerCase().trim()),
      firstName: this.sanitize(data.firstName.trim()),
      lastName: this.sanitize(data.lastName.trim()),
      role: USER_ROLES.ASSISTANT
    };
  }

  validateCustomer(data, currentUserRole, assistantId = null, isUpdate = false) {
    const validated = {};
    
    // Basic validation
    if (!isUpdate) {
      if (!data.email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
        throw new Error('Valid email is required');
      }
      validated.email = this.sanitize(data.email.toLowerCase().trim());
    }
    
    if (!isUpdate && (!data.firstName || !data.lastName || data.firstName.length < 2 || data.lastName.length < 2)) {
      throw new Error('First and last names are required (2+ characters)');
    }
    
    if (data.firstName) validated.firstName = this.sanitize(data.firstName.trim());
    if (data.lastName) validated.lastName = this.sanitize(data.lastName.trim());
    if (data.phone) validated.phone = this.sanitize(data.phone.replace(/\s/g, ''));
    if (data.company) validated.company = this.sanitize(data.company.trim());
    
    // Financial data validation - ONLY admins can modify
    if (currentUserRole === USER_ROLES.ADMIN) {
      if (data.creditLimit !== undefined) {
        const limit = parseFloat(data.creditLimit);
        if (isNaN(limit) || limit < 0 || limit > VALIDATION_RULES.MAX_CREDIT_LIMIT) {
          throw new Error(`Credit limit must be between 0 and ${VALIDATION_RULES.MAX_CREDIT_LIMIT}`);
        }
        validated.creditLimit = limit;
      }
      if (data.paymentTerms && VALIDATION_RULES.PAYMENT_TERMS.includes(data.paymentTerms)) {
        validated.paymentTerms = data.paymentTerms;
      }
    } else {
      // Check if assistant is trying to modify financial data
      const financialFields = FINANCIAL_FIELDS.filter(field => data[field] !== undefined);
      if (financialFields.length > 0) {
        throw new Error(ERROR_MESSAGES.FINANCIAL_ACCESS_DENIED);
      }
    }
    
    // Add ownership for assistants
    if (currentUserRole === USER_ROLES.ASSISTANT && !isUpdate) {
      validated.createdBy = assistantId;
    }
    
    return validated;
  }

  validateOrder(data, currentUserRole, assistantId = null) {
    if (!data.customerId) {
      throw new Error('Customer ID is required');
    }
    if (!data.items || !Array.isArray(data.items) || data.items.length === 0) {
      throw new Error('Order must contain at least one item');
    }
    
    const validated = {
      customerId: this.sanitize(data.customerId.toString()),
      items: [],
      totalAmount: 0
    };
    
    // Role-based price limits
    const maxPrice = currentUserRole === USER_ROLES.ADMIN ? 
      VALIDATION_RULES.ADMIN_MAX_ITEM_PRICE : 
      VALIDATION_RULES.ASSISTANT_MAX_ITEM_PRICE;
    
    data.items.forEach((item, index) => {
      if (!item.productId) throw new Error(`Item ${index + 1}: Product ID is required`);
      
      const quantity = parseInt(item.quantity);
      const price = parseFloat(item.price);
      
      if (!quantity || quantity < 1 || quantity > VALIDATION_RULES.MAX_ITEM_QUANTITY) {
        throw new Error(`Item ${index + 1}: Quantity must be 1-${VALIDATION_RULES.MAX_ITEM_QUANTITY}`);
      }
      if (isNaN(price) || price < 0 || price > maxPrice) {
        throw new Error(`Item ${index + 1}: Invalid price or exceeds ${maxPrice} limit`);
      }
      
      const subtotal = quantity * price;
      validated.items.push({
        productId: this.sanitize(item.productId.toString()),
        quantity,
        price,
        subtotal
      });
      validated.totalAmount += subtotal;
    });
    
    // Role-based order value limits
    const maxOrderValue = currentUserRole === USER_ROLES.ADMIN ? 
      VALIDATION_RULES.ADMIN_MAX_ORDER_VALUE : 
      VALIDATION_RULES.ASSISTANT_MAX_ORDER_VALUE;
    
    if (validated.totalAmount > maxOrderValue) {
      throw new Error(`Order total exceeds ${maxOrderValue} limit for ${currentUserRole}s`);
    }
    
    if (data.notes) {
      const maxLength = currentUserRole === USER_ROLES.ADMIN ? 1000 : 500;
      if (data.notes.length > maxLength) {
        throw new Error(`Notes exceed ${maxLength} character limit`);
      }
      validated.notes = this.sanitize(data.notes.trim());
    }
    
    // Only admins can set priority
    if (data.priority) {
      if (currentUserRole !== USER_ROLES.ADMIN) {
        throw new Error(ERROR_MESSAGES.ADMIN_ONLY_OPERATION);
      }
      if (['low', 'normal', 'high', 'urgent'].includes(data.priority)) {
        validated.priority = data.priority;
      }
    }
    
    // Add receivedBy for currently logged-in assistant
    if (currentUserRole === USER_ROLES.ASSISTANT) {
      validated.receivedBy = assistantId;
      validated.receivedAt = new Date();
    }
    
    return validated;
  }

  // FIXED: Proper data ownership validation
  validateDataOwnership(resourceType, resourceId, currentUserRole, assistantId, resourceData = null) {
    // Admins can access everything
    if (currentUserRole === USER_ROLES.ADMIN) return true;
    
    // Assistants can only access their own data
    if (currentUserRole === USER_ROLES.ASSISTANT) {
      if (resourceType === 'customer' || resourceType === 'order') {
        // If we have resource data, check ownership
        if (resourceData && resourceData.createdBy !== assistantId) {
          throw new Error(ERROR_MESSAGES.OWNERSHIP_VIOLATION);
        }
        return true;
      }
      
      // Assistants cannot access users or financial data
      if (resourceType === 'user' || resourceType === 'financial_data') {
        throw new Error(ERROR_MESSAGES.ACCESS_DENIED);
      }
    }
    
    return false;
  }

  // FIXED: Proper delete permissions
  validateDeletePermission(resourceType, currentUserRole) {
    if (currentUserRole === USER_ROLES.ADMIN) return true;
    
    // Assistants cannot delete anything
    if (currentUserRole === USER_ROLES.ASSISTANT) {
      throw new Error(ERROR_MESSAGES.DELETE_DENIED);
    }
    
    return false;
  }

  // Check if user can access financial data
  validateFinancialAccess(currentUserRole) {
    if (currentUserRole === USER_ROLES.ASSISTANT) {
      throw new Error(ERROR_MESSAGES.FINANCIAL_ACCESS_DENIED);
    }
    return currentUserRole === USER_ROLES.ADMIN;
  }

  // Filter financial fields from response data
  filterFinancialData(data, currentUserRole) {
    if (currentUserRole === USER_ROLES.ADMIN) {
      return data; // Admins see everything
    }
    
    if (Array.isArray(data)) {
      return data.map(item => this.removeFinancialFields(item));
    } else {
      return this.removeFinancialFields(data);
    }
  }

  removeFinancialFields(obj) {
    if (!obj || typeof obj !== 'object') return obj;
    
    const filtered = { ...obj };
    FINANCIAL_FIELDS.forEach(field => {
      delete filtered[field];
    });
    
    return filtered;
  }

  validateFileUpload(files, maxSize = 10 * 1024 * 1024, allowedTypes = ['image/jpeg', 'image/png', 'application/pdf']) {
    if (!files || files.length === 0) throw new Error('No files provided');
    if (files.length > 5) throw new Error('Maximum 5 files allowed');
    
    return Array.from(files).map((file, index) => {
      if (file.size > maxSize) {
        throw new Error(`File ${index + 1}: Size exceeds ${maxSize / 1024 / 1024}MB limit`);
      }
      if (!allowedTypes.includes(file.type)) {
        throw new Error(`File ${index + 1}: Type not allowed`);
      }
      return file;
    });
  }

  validateRequest(validationType) {
    return (req, res, next) => {
      // FIXED: Move userRole declaration outside try-catch to make it accessible in catch block
      const userRole = req.user?.role || USER_ROLES.ASSISTANT;
      const assistantId = req.user?.id;
      
      try {
        let validatedData;
        
        switch (validationType) {
          case 'login':
            validatedData = this.validateLogin(req.body);
            break;
          case 'userRegistration':
            validatedData = this.validateUserRegistration(req.body, userRole);
            break;
          case 'assistant':
            validatedData = this.validateAssistant(req.body, userRole);
            break;
          case 'customer':
            validatedData = this.validateCustomer(req.body, userRole, assistantId, req.method === 'PUT');
            break;
          case 'order':
            validatedData = this.validateOrder(req.body, userRole, assistantId);
            break;
          case 'fileUpload':
            validatedData = this.validateFileUpload(req.files);
            break;
          default:
            throw new Error('Unknown validation type');
        }
        
        req.validatedData = validatedData;
        next();
        
      } catch (error) {
        // Log security violations
        if (error.message.includes('ownership') || error.message.includes('financial')) {
          console.warn('Security Violation:', {
            userId: req.user?.id,
            role: req.user?.role,
            action: validationType,
            error: error.message,
            ip: req.ip,
            timestamp: new Date()
          });
        }
        
        res.status(400).json({
          error: userRole === USER_ROLES.ADMIN ? error.message : 'Access denied or invalid data',
          code: 'VALIDATION_ERROR'
        });
      }
    };
  }

  // Middleware to add ownership filter for assistants
  addOwnershipFilter() {
    return (req, res, next) => {
      if (req.user?.role === USER_ROLES.ASSISTANT) {
        req.ownershipFilter = { createdBy: req.user.id };
      }
      next();
    };
  }

  // Middleware to add financial data filtering
  addFinancialDataFilter() {
    return (req, res, next) => {
      if (req.user?.role === USER_ROLES.ASSISTANT) {
        req.filterFinancialData = true;
      }
      next();
    };
  }
}

module.exports = ValidationMiddleware;